# -*- coding: utf-8 -*-
"""proyecto_recibos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1__ihptw1-W779N2E5u5ykjqPNzHazBxU
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

def preprocesar_recibo(ruta_imagen):
    """
    Función para preprocesar una imagen de recibo siguiendo varios pasos
    para mejorar la calidad y facilitar la extracción de información.

    Args:
        ruta_imagen (str): Ruta al archivo de imagen del recibo (JPG o PNG)

    Returns:
        tuple: Tupla conteniendo todas las etapas de la imagen procesada
    """
    # Paso 1: Cargar la imagen original
    print("Cargando imagen desde:", ruta_imagen)
    imagen_original = cv2.imread(ruta_imagen)

    if imagen_original is None:
        raise ValueError(f"No se pudo cargar la imagen desde {ruta_imagen}. Verifica la ruta y el formato.")

    # Hacer una copia de la imagen original en formato RGB para visualización
    imagen_rgb = cv2.cvtColor(imagen_original, cv2.COLOR_BGR2RGB)

    # Paso 2: Convertir a escala de grises
    print("Convirtiendo a escala de grises...")
    imagen_gris = cv2.cvtColor(imagen_original, cv2.COLOR_BGR2GRAY)

    # Paso 3: Aplicar filtro Gaussian Blur para reducir ruido
    # Usamos un kernel 5x5 que es adecuado para la mayoría de imágenes de recibos
    print("Aplicando filtro Gaussian Blur...")
    kernel_size = (5, 5)
    sigma = 0  # Valor 0 significa que OpenCV calculará automáticamente el valor sigma
    imagen_blur = cv2.GaussianBlur(imagen_gris, kernel_size, sigma)

    # Paso 4: Aplicar binarización con método de Otsu
    # Este método determina automáticamente el umbral óptimo para la binarización
    print("Aplicando binarización con método de Otsu...")
    _, imagen_binaria = cv2.threshold(imagen_blur, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)

    # Opcionalmente, podemos mejorar los resultados con operaciones morfológicas
    # como dilate para hacer el texto más legible y eliminar algunos ruidos
    kernel = np.ones((2, 2), np.uint8)
    imagen_final = cv2.dilate(imagen_binaria, kernel, iterations=1)

    print("Preprocesamiento completado.")

    return imagen_rgb, imagen_gris, imagen_blur, imagen_binaria, imagen_final

def mostrar_resultados(imagenes, titulos):
    """
    Función para mostrar las imágenes resultantes en ventanas separadas

    Args:
        imagenes (list): Lista de imágenes a mostrar
        titulos (list): Lista de títulos para cada imagen
    """
    # Configurar el tamaño de las figuras
    plt.figure(figsize=(15, 10))

    # Mostrar cada imagen en un subplot
    for i, (imagen, titulo) in enumerate(zip(imagenes, titulos)):
        plt.subplot(2, 3, i + 1)

        # Para imágenes en escala de grises o binarias, usar colormap 'gray'
        if len(imagen.shape) == 2:
            plt.imshow(imagen, cmap='gray')
        else:
            plt.imshow(imagen)

        plt.title(titulo)
        plt.axis('off')  # Ocultar ejes

    plt.tight_layout()
    plt.show()

# Función principal para ejecutar el script
def main():
    # Ruta de la imagen a procesar - reemplazar con la ruta correcta
    ruta_imagen = "ruta/a/tu/recibo.jpg"

    try:
        # Realizar el preprocesamiento
        imagen_rgb, imagen_gris, imagen_blur, imagen_binaria, imagen_final = preprocesar_recibo(ruta_imagen)

        # Mostrar los resultados
        titulos = [
            "Imagen Original",
            "Escala de Grises",
            "Gaussian Blur",
            "Binarización Otsu",
            "Imagen Final (con Dilatación)"
        ]

        imagenes = [imagen_rgb, imagen_gris, imagen_blur, imagen_binaria, imagen_final]
        mostrar_resultados(imagenes, titulos)

    except Exception as e:
        print(f"Error: {e}")

# Ejecutar el script si se llama directamente
if __name__ == "__main__":
    main()